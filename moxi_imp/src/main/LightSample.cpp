/*
-----------------------------------------------------------------------------
Filename:    LightSample.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.8.x Application Wizard for VC9 (May 2012)
      https://bitbucket.org/jacmoe/ogreappwizards
-----------------------------------------------------------------------------
*/

#include "LightSample.h"

//-------------------------------------------------------------------------------------
LightSample::LightSample(void)
{
}
//-------------------------------------------------------------------------------------
LightSample::~LightSample(void)
{
}

//-------------------------------------------------------------------------------------
void LightSample::createScene(void)
{
	using namespace Ogre;

	TexturePtr tex = TextureManager::getSingleton().createManual("MirrorReflection",
		ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, TEX_TYPE_2D, 512, 512, 0, PF_R8G8B8, TU_RENDERTARGET);

	mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE);
    Ogre::Entity* ogreHead = mSceneMgr->createEntity("Head", "ogrehead.mesh");

    Ogre::SceneNode* headNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    headNode->attachObject(ogreHead);
	headNode->setScale(0.1, 0.1, 0.1);
	headNode->setPosition(0, 5, 0);

    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.1, 0.1, 0.1));

    // Create a light
    l1 = mSceneMgr->createLight("MainLight");
    l1->setPosition(2,10,2);
	l1->setDirection(0, -1, 0);
	l1->setType(Light::LightTypes::LT_DIRECTIONAL);
	l1->setSpecularColour(0.9, 0.9, 0.9);

	l2 = mSceneMgr->createLight("PointL");
	l2->setPosition(-3,10,0);
	l2->setType(Light::LightTypes::LT_POINT);
	l2->setVisible(false);
	l1->setSpecularColour(0.9, 0.9, 0.9);

	l3 = mSceneMgr->createLight("PointSP");
	l3->setPosition(5,10,0);
	l3->setDirection(0, -1, 0);
	l3->setSpotlightOuterAngle(Radian(10));
	l3->setType(Light::LightTypes::LT_SPOTLIGHT);
	l3->setVisible(false);

	 MirrorPlane = Plane(Vector3::UNIT_Y, 0);
	MeshManager::getSingleton().createPlane("floor", ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,
		MirrorPlane, 100, 100, 10, 10, true, 1, 10, 10, Vector3::UNIT_Z);
	mMirrorEnt = mSceneMgr->createEntity("Floor", "floor");
	mMirrorEnt->setMaterialName("MirrorPlane");
	mMirrorEnt->setCastShadows(false);
	mSceneMgr->getRootSceneNode()->attachObject(mMirrorEnt);


// 	RenderTarget* rtt = tex->getBuffer()->getRenderTarget();
// 	rtt->addViewport(mCamera)->setOverlaysEnabled(false);
// 	rtt->addListener(this);
// 
// 	mMirrorTarget = rtt;

	CompositorManager::getSingleton().addCompositor(mCamera->getViewport(), "Glow");
	CompositorManager::getSingleton().setCompositorEnabled(mCamera->getViewport(), "Glow", true);
	GlowMaterialListener *gml = new GlowMaterialListener();
	Ogre::MaterialManager::getSingleton().addListener(gml);

	mGlowObjEnt = mSceneMgr->createEntity("GlowPG", "penguin.mesh");
	mGlowObjNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
	mGlowObjEnt->setMaterialName("GlowMt");
	mGlowObjNode->attachObject(mGlowObjEnt);
	mGlowObjNode->setPosition(10,10,0);
	mGlowObjNode->setScale(0.2, 0.2, 0.2);
	Ogre::MaterialPtr mpt = MaterialManager::getSingleton().getByName("GlowMt");
	fpPP = mpt->getTechnique(1)->getPass(0)->getFragmentProgramParameters();
	dtime = 0;
}

bool LightSample::keyPressed( const OIS::KeyEvent &arg )
{
	if (arg.key == OIS::KC_1)
		mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));
	if (arg.key == OIS::KC_2)
		mSceneMgr->setAmbientLight(Ogre::ColourValue(0.0, 0.0, 0.0));

	if (arg.key == OIS::KC_3)
		l1->setVisible(!l1->getVisible());
	if (arg.key == OIS::KC_4)
		l2->setVisible(!l2->getVisible());
	if (arg.key == OIS::KC_5)
		l3->setVisible(!l3->getVisible());

	if (arg.key == OIS::KC_NUMPAD0)
		mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE);
	if (arg.key == OIS::KC_NUMPAD1)
		mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_ADDITIVE);
	if (arg.key == OIS::KC_NUMPAD2)
		mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_TEXTURE_MODULATIVE);
	if (arg.key == OIS::KC_NUMPAD3)
		mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_STENCIL_MODULATIVE);

	return BaseApplication::keyPressed(arg);
}

void LightSample::preRenderTargetUpdate( const Ogre::RenderTargetEvent& evt )
{

// 	if (evt.source == mMirrorTarget)  // for reflection, turn on camera reflection and hide submerged entities
// 	{
// 		mMirrorEnt->setVisible(false);
// 		mCamera->enableReflection(MirrorPlane);
// 	}
}

void LightSample::postRenderTargetUpdate( const Ogre::RenderTargetEvent& evt )
{
// 	if (evt.source == mMirrorTarget)  // for reflection, turn on camera reflection and hide submerged entities
// 	{
// 		mMirrorEnt->setVisible(true);
// 		mCamera->disableReflection();
// 	}
}

bool LightSample::frameRenderingQueued( const Ogre::FrameEvent& evt )
{
	dtime+=evt.timeSinceLastFrame*0.5;
	if (dtime>1.0f)
		dtime-=1.0f;
	fpPP->setNamedConstant("time", &dtime, 1);
	return BaseApplication::frameRenderingQueued(evt);
}
